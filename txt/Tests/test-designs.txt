### Manual Testing:

Manual testing is the process of manually executing test cases without using automation tools. Testers interact with the application to identify defects and ensure its functionality.
### Automated Testing:

Automated testing involves the use of testing tools and scripts to automate test case execution. It is especially useful for regression testing and repetitive tasks.
### Functional Testing:

Functional testing verifies that the application functions according to specified requirements. It includes:
Unit Testing: Testing individual components or functions.
Integration Testing: Testing the interaction between components/modules.
System Testing: Testing the complete application as a whole.
### Non-Functional Testing:

Non-functional testing evaluates non-functional aspects of the application, such as performance, usability, security, and scalability. Examples include load testing and security testing.
### Black Box Testing:

Black box testing focuses on testing the application's functionality without knowledge of its internal code. Testers validate inputs and expected outputs.
### White Box Testing:

White box testing, also known as structural testing, examines the internal code and logic of the application. Testers design test cases based on code coverage criteria.
### Grey Box Testing:

Grey box testing combines aspects of both black box and white box testing. Testers have partial knowledge of the application's internal structure.
### User Acceptance Testing (UAT):

UAT is performed by end-users or stakeholders to validate whether the application meets their requirements and expectations.
### Regression Testing:

Regression testing ensures that new changes or enhancements do not introduce defects into existing functionality. It involves retesting existing test cases.
### Ad-Hoc Testing:

Ad-hoc testing is performed informally without predefined test cases. Testers use their domain knowledge to find defects.
### Boundary Testing:

Boundary testing evaluates how the application handles boundary values or extreme inputs.
### Equivalence Partitioning:

Equivalence partitioning divides input values into groups or partitions, with the assumption that values within the same group behave the same way.
### Stress Testing:

Stress testing evaluates how the application performs under extreme conditions, such as high load or resource constraints.
### Compatibility Testing:

Compatibility testing ensures that the application functions correctly on different platforms, browsers, and devices.
### Usability Testing:

Usability testing assesses the application's user-friendliness, including user interface design and ease of navigation.
### Security Testing:

Security testing checks for vulnerabilities and threats to ensure the application is secure from potential attacks.
### Performance Testing:

Performance testing measures the application's response time, scalability, and resource utilization under different scenarios.
