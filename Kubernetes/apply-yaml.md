 Допустим, у вас есть YAML-файл, в котором описаны deployment и service. Вы вводите команду kubectl create -f file.yaml . Как можно подробнее опишите, что произойдёт после нажатия клавиши Enter.

 
— Прежде всего утилита kubectl найдёт и считает kubeconfig, возьмёт оттуда адрес Kubernetes API, сертификаты для его проверки, ключ доступа к нему и сделает запрос.

Kubernetes API получит запрос, проверит права пользователя, которому принадлежит ключ, и, если права позволяют, запишет в ETCD информацию о новом deployment и service.

Kubernetes controller manager увидит, что описан deployment, и при помощи Kubernetes API запишет в ETCD информацию о создании replicaset и нужного количества PODов на его основе. На этом этапе в работу могут включиться admission controller’ы, которые способны провалидировать корректность PODов или трансформировать их.

Kubernetes scheduler увидит информацию о новых POD'ах и на основе их параметров (настроек требуемых ресурсов, nodeSelector'ов, taints/tolerations, podAntiAffinity и прочего) назначит PODы на подходящие ноды.

Kubelet, в очередной раз опросив Kubernetes API, увидит изменение конфигурации ноды и начнёт вносить изменения: запустит контейнеры посредством CRI, даст команду kube-proxy на конфигурацию сети, запустит пробы, когда пробы будут пройдены, изменит в ETCD статус POD’а посредством Kubernetes API на Ready.

Kubernetes controller manager увидит, что появились PODы в статусе Ready, которые соответствуют меткам, описанным в service, и создаст записи о новых Endpoint’ах для соответствующих PODов.

Kubelet’ы на всех нодах кластера увидят изменение конфигурации и вызовут kube-proxy для создания Endpoint’ов.

Kube-proxy вызовут CNI-плагины, которые реализуют Endpoint’ы на уровне инфраструктуры.

При обращении к сервису трафик пойдёт на новые PODы.